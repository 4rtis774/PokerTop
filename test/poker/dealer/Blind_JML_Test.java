// This file was generated by jmlunit on Mon May 31 15:12:52 CEST 2010.

package poker.dealer;

/** Automatically-generated test driver for JML and JUnit based
 * testing of Blind. The superclass of this class should be edited
 * to supply test data. However it's best not to edit this class
 * directly; instead use the command
 * <pre>
 *  jmlunit Blind.java
 * </pre>
 * to regenerate this class whenever Blind.java changes.
 */
public class Blind_JML_Test
     extends Blind_JML_TestData
{
    /** Initialize this class. */
    public Blind_JML_Test(java.lang.String name) {
        super(name);
    }

    /** Run the tests. */
    public static void main(java.lang.String[] args) {
        org.jmlspecs.jmlunit.JMLTestRunner.run(suite());
        // You can also use a JUnit test runner such as:
        // junit.textui.TestRunner.run(suite());
    }

    /** Test to see if the code for class Blind
     * has been compiled with runtime assertion checking (i.e., by jmlc).
     * Code that is not compiled with jmlc would not make an effective test,
     * since no assertion checking would be done. */
    public void test$IsRACCompiled() {
        junit.framework.Assert.assertTrue("code for class Blind"
                + " was not compiled with jmlc"
                + " so no assertions will be checked!",
            org.jmlspecs.jmlrac.runtime.JMLChecker.isRACCompiled(Blind.class)
            );
    }

    /** Return the test suite for this test class.  This will have
    * added to it at least test$IsRACCompiled(), and any test methods
    * written explicitly by the user in the superclass.  It will also
    * have added test suites for each testing each method and
    * constructor.
    */
    //@ ensures \result != null;
    public static junit.framework.Test suite() {
        Blind_JML_Test testobj
            = new Blind_JML_Test("Blind_JML_Test");
        junit.framework.TestSuite testsuite = testobj.overallTestSuite();
        // Add instances of Test found by the reflection mechanism.
        testsuite.addTestSuite(Blind_JML_Test.class);
        testobj.addTestSuiteForEachMethod(testsuite);
        return testsuite;
    }

    /** A JUnit test object that can run a single test method.  This
     * is defined as a nested class solely for convenience; it can't
     * be defined once and for all because it must subclass its
     * enclosing class.
     */
    protected static abstract class OneTest extends Blind_JML_Test {

        /** Initialize this test object. */
        public OneTest(String name) {
            super(name);
        }

        /** The result object that holds information about testing. */
        protected junit.framework.TestResult result;

        //@ also
        //@ requires result != null;
        public void run(junit.framework.TestResult result) {
            this.result = result;
            super.run(result);
        }

        /* Run a single test and decide whether the test was
         * successful, meaningless, or a failure.  This is the
         * Template Method pattern abstraction of the inner loop in a
         * JML/JUnit test. */
        public void runTest() throws java.lang.Throwable {
            try {
                // The call being tested!
                doCall();
            }
            catch (org.jmlspecs.jmlrac.runtime.JMLEntryPreconditionError e) {
                // meaningless test input
                addMeaningless();
            } catch (org.jmlspecs.jmlrac.runtime.JMLAssertionError e) {
                // test failure
                int l = org.jmlspecs.jmlrac.runtime.JMLChecker.getLevel();
                org.jmlspecs.jmlrac.runtime.JMLChecker.setLevel
                    (org.jmlspecs.jmlrac.runtime.JMLOption.NONE);
                try {
                    java.lang.String failmsg = this.failMessage(e);
                    junit.framework.AssertionFailedError err
                        = new junit.framework.AssertionFailedError(failmsg);
                    err.setStackTrace(new java.lang.StackTraceElement[]{});
                    err.initCause(e);
                    result.addFailure(this, err);
                } finally {
                    org.jmlspecs.jmlrac.runtime.JMLChecker.setLevel(l);
                }
            } catch (java.lang.Throwable e) {
                // test success
            }
        }

        /** Call the method to be tested with the appropriate arguments. */
        protected abstract void doCall() throws java.lang.Throwable;

        /** Format the error message for a test failure, based on the
         * method's arguments. */
        protected abstract java.lang.String failMessage
            (org.jmlspecs.jmlrac.runtime.JMLAssertionError e);

        /** Inform listeners that a meaningless test was run. */
        private void addMeaningless() {
            if (result instanceof org.jmlspecs.jmlunit.JMLTestResult) {
                ((org.jmlspecs.jmlunit.JMLTestResult)result)
                    .addMeaningless(this);
            }
        }
    }

    /** Create the tests that are to be run for testing the class
     * Blind.  The framework will then run them.
     * @param overallTestSuite$ The suite accumulating all of the tests
     * for this driver class.
     */
    //@ requires overallTestSuite$ != null;
    public void addTestSuiteForEachMethod
        (junit.framework.TestSuite overallTestSuite$)
    {
        try {
            this.addTestSuiteFor$TestBlind(overallTestSuite$);
        } catch (java.lang.Throwable ex) {
            overallTestSuite$.addTest
                (new org.jmlspecs.jmlunit.strategies.ConstructorFailed(ex));
        }
        try {
            this.addTestSuiteFor$TestIncreaseBlind(overallTestSuite$);
        } catch (java.lang.Throwable ex) {
            overallTestSuite$.addTest
                (new org.jmlspecs.jmlunit.strategies.ConstructorFailed(ex));
        }
        try {
            this.addTestSuiteFor$TestGetAnte(overallTestSuite$);
        } catch (java.lang.Throwable ex) {
            overallTestSuite$.addTest
                (new org.jmlspecs.jmlunit.strategies.ConstructorFailed(ex));
        }
        try {
            this.addTestSuiteFor$TestSetAnte(overallTestSuite$);
        } catch (java.lang.Throwable ex) {
            overallTestSuite$.addTest
                (new org.jmlspecs.jmlunit.strategies.ConstructorFailed(ex));
        }
        try {
            this.addTestSuiteFor$TestGetBig(overallTestSuite$);
        } catch (java.lang.Throwable ex) {
            overallTestSuite$.addTest
                (new org.jmlspecs.jmlunit.strategies.ConstructorFailed(ex));
        }
        try {
            this.addTestSuiteFor$TestSetBig(overallTestSuite$);
        } catch (java.lang.Throwable ex) {
            overallTestSuite$.addTest
                (new org.jmlspecs.jmlunit.strategies.ConstructorFailed(ex));
        }
        try {
            this.addTestSuiteFor$TestGetSmall(overallTestSuite$);
        } catch (java.lang.Throwable ex) {
            overallTestSuite$.addTest
                (new org.jmlspecs.jmlunit.strategies.ConstructorFailed(ex));
        }
        try {
            this.addTestSuiteFor$TestSetSmall(overallTestSuite$);
        } catch (java.lang.Throwable ex) {
            overallTestSuite$.addTest
                (new org.jmlspecs.jmlunit.strategies.ConstructorFailed(ex));
        }
    }

    /** Add tests for the Blind contructor
     * to the overall test suite. */
    private void addTestSuiteFor$TestBlind
        (junit.framework.TestSuite overallTestSuite$)
    {
        junit.framework.TestSuite methodTests$
            = this.emptyTestSuiteFor("Blind");
        try {
            org.jmlspecs.jmlunit.strategies.DoubleIterator
                vdouble$1$iter
                = this.vdoubleIter("Blind", 2);
            this.check_has_data
                (vdouble$1$iter,
                 "this.vdoubleIter(\"Blind\", 2)");
            while (!vdouble$1$iter.atEnd()) {
                org.jmlspecs.jmlunit.strategies.DoubleIterator
                    vdouble$2$iter
                    = this.vdoubleIter("Blind", 1);
                this.check_has_data
                    (vdouble$2$iter,
                     "this.vdoubleIter(\"Blind\", 1)");
                while (!vdouble$2$iter.atEnd()) {
                    org.jmlspecs.jmlunit.strategies.DoubleIterator
                        vdouble$3$iter
                        = this.vdoubleIter("Blind", 0);
                    this.check_has_data
                        (vdouble$3$iter,
                         "this.vdoubleIter(\"Blind\", 0)");
                    while (!vdouble$3$iter.atEnd()) {
                        final double smallBlind
                            = vdouble$1$iter.getDouble();
                        final double bigBlind
                            = vdouble$2$iter.getDouble();
                        final double anteSize
                            = vdouble$3$iter.getDouble();
                        methodTests$.addTest
                            (new TestBlind(smallBlind, bigBlind, anteSize));
                        vdouble$3$iter.advance();
                    }
                    vdouble$2$iter.advance();
                }
                vdouble$1$iter.advance();
            }
        } catch (org.jmlspecs.jmlunit.strategies.TestSuiteFullException e$) {
            // methodTests$ doesn't want more tests
        }
        overallTestSuite$.addTest(methodTests$);
    }

    /** Test for the Blind contructor. */
    protected static class TestBlind extends OneTest {
        /** Argument smallBlind */
        private double smallBlind;
        /** Argument bigBlind */
        private double bigBlind;
        /** Argument anteSize */
        private double anteSize;

        /** Initialize this instance. */
        public TestBlind(double smallBlind, double bigBlind, double anteSize) {
            super("Blind"+ ":" + smallBlind+ "," +bigBlind+ "," +anteSize);
            this.smallBlind = smallBlind;
            this.bigBlind = bigBlind;
            this.anteSize = anteSize;
        }

        protected void doCall() throws java.lang.Throwable {
            new Blind(smallBlind, bigBlind, anteSize);
        }

        protected java.lang.String failMessage
            (org.jmlspecs.jmlrac.runtime.JMLAssertionError e$)
        {
            java.lang.String msg = "\n\tContructor 'Blind' applied to";
            msg += "\n\tArgument smallBlind: " + this.smallBlind;
            msg += "\n\tArgument bigBlind: " + this.bigBlind;
            msg += "\n\tArgument anteSize: " + this.anteSize;
            return msg;
        }
    }

    /** Add tests for the increaseBlind method
     * to the overall test suite. */
    private void addTestSuiteFor$TestIncreaseBlind
        (junit.framework.TestSuite overallTestSuite$)
    {
        junit.framework.TestSuite methodTests$
            = this.emptyTestSuiteFor("increaseBlind");
        try {
            org.jmlspecs.jmlunit.strategies.IndefiniteIterator
                receivers$iter
                = new org.jmlspecs.jmlunit.strategies.NonNullIteratorDecorator
                    (this.vpoker_dealer_BlindIter("increaseBlind", 3));
            this.check_has_data
                (receivers$iter,
                 "new NonNullIteratorDecorator(this.vpoker_dealer_BlindIter(\"increaseBlind\", 3))");
            while (!receivers$iter.atEnd()) {
                org.jmlspecs.jmlunit.strategies.DoubleIterator
                    vdouble$1$iter
                    = this.vdoubleIter("increaseBlind", 2);
                this.check_has_data
                    (vdouble$1$iter,
                     "this.vdoubleIter(\"increaseBlind\", 2)");
                while (!vdouble$1$iter.atEnd()) {
                    org.jmlspecs.jmlunit.strategies.DoubleIterator
                        vdouble$2$iter
                        = this.vdoubleIter("increaseBlind", 1);
                    this.check_has_data
                        (vdouble$2$iter,
                         "this.vdoubleIter(\"increaseBlind\", 1)");
                    while (!vdouble$2$iter.atEnd()) {
                        org.jmlspecs.jmlunit.strategies.DoubleIterator
                            vdouble$3$iter
                            = this.vdoubleIter("increaseBlind", 0);
                        this.check_has_data
                            (vdouble$3$iter,
                             "this.vdoubleIter(\"increaseBlind\", 0)");
                        while (!vdouble$3$iter.atEnd()) {
                            final poker.dealer.Blind receiver$
                                = (poker.dealer.Blind) receivers$iter.get();
                            final double newSmallBlind
                                = vdouble$1$iter.getDouble();
                            final double newBigBlind
                                = vdouble$2$iter.getDouble();
                            final double newAnteSize
                                = vdouble$3$iter.getDouble();
                            methodTests$.addTest
                                (new TestIncreaseBlind(receiver$, newSmallBlind, newBigBlind, newAnteSize));
                            vdouble$3$iter.advance();
                        }
                        vdouble$2$iter.advance();
                    }
                    vdouble$1$iter.advance();
                }
                receivers$iter.advance();
            }
        } catch (org.jmlspecs.jmlunit.strategies.TestSuiteFullException e$) {
            // methodTests$ doesn't want more tests
        }
        overallTestSuite$.addTest(methodTests$);
    }

    /** Test for the increaseBlind method. */
    protected static class TestIncreaseBlind extends OneTest {
        /** The receiver */
        private poker.dealer.Blind receiver$;
        /** Argument newSmallBlind */
        private double newSmallBlind;
        /** Argument newBigBlind */
        private double newBigBlind;
        /** Argument newAnteSize */
        private double newAnteSize;

        /** Initialize this instance. */
        public TestIncreaseBlind(poker.dealer.Blind receiver$, double newSmallBlind, double newBigBlind, double newAnteSize) {
            super("increaseBlind"+ ":" + newSmallBlind+ "," +newBigBlind+ "," +newAnteSize);
            this.receiver$ = receiver$;
            this.newSmallBlind = newSmallBlind;
            this.newBigBlind = newBigBlind;
            this.newAnteSize = newAnteSize;
        }

        protected void doCall() throws java.lang.Throwable {
            receiver$.increaseBlind(newSmallBlind, newBigBlind, newAnteSize);
        }

        protected java.lang.String failMessage
            (org.jmlspecs.jmlrac.runtime.JMLAssertionError e$)
        {
            java.lang.String msg = "\n\tMethod 'increaseBlind' applied to";
            msg += "\n\tReceiver: " + this.receiver$;
            msg += "\n\tArgument newSmallBlind: " + this.newSmallBlind;
            msg += "\n\tArgument newBigBlind: " + this.newBigBlind;
            msg += "\n\tArgument newAnteSize: " + this.newAnteSize;
            return msg;
        }
    }

    /** Add tests for the getAnte method
     * to the overall test suite. */
    private void addTestSuiteFor$TestGetAnte
        (junit.framework.TestSuite overallTestSuite$)
    {
        junit.framework.TestSuite methodTests$
            = this.emptyTestSuiteFor("getAnte");
        try {
            org.jmlspecs.jmlunit.strategies.IndefiniteIterator
                receivers$iter
                = new org.jmlspecs.jmlunit.strategies.NonNullIteratorDecorator
                    (this.vpoker_dealer_BlindIter("getAnte", 0));
            this.check_has_data
                (receivers$iter,
                 "new NonNullIteratorDecorator(this.vpoker_dealer_BlindIter(\"getAnte\", 0))");
            while (!receivers$iter.atEnd()) {
                final poker.dealer.Blind receiver$
                    = (poker.dealer.Blind) receivers$iter.get();
                methodTests$.addTest
                    (new TestGetAnte(receiver$));
                receivers$iter.advance();
            }
        } catch (org.jmlspecs.jmlunit.strategies.TestSuiteFullException e$) {
            // methodTests$ doesn't want more tests
        }
        overallTestSuite$.addTest(methodTests$);
    }

    /** Test for the getAnte method. */
    protected static class TestGetAnte extends OneTest {
        /** The receiver */
        private poker.dealer.Blind receiver$;

        /** Initialize this instance. */
        public TestGetAnte(poker.dealer.Blind receiver$) {
            super("getAnte");
            this.receiver$ = receiver$;
        }

        protected void doCall() throws java.lang.Throwable {
            receiver$.getAnte();
        }

        protected java.lang.String failMessage
            (org.jmlspecs.jmlrac.runtime.JMLAssertionError e$)
        {
            java.lang.String msg = "\n\tMethod 'getAnte' applied to";
            msg += "\n\tReceiver: " + this.receiver$;
            return msg;
        }
    }

    /** Add tests for the setAnte method
     * to the overall test suite. */
    private void addTestSuiteFor$TestSetAnte
        (junit.framework.TestSuite overallTestSuite$)
    {
        junit.framework.TestSuite methodTests$
            = this.emptyTestSuiteFor("setAnte");
        try {
            org.jmlspecs.jmlunit.strategies.IndefiniteIterator
                receivers$iter
                = new org.jmlspecs.jmlunit.strategies.NonNullIteratorDecorator
                    (this.vpoker_dealer_BlindIter("setAnte", 1));
            this.check_has_data
                (receivers$iter,
                 "new NonNullIteratorDecorator(this.vpoker_dealer_BlindIter(\"setAnte\", 1))");
            while (!receivers$iter.atEnd()) {
                org.jmlspecs.jmlunit.strategies.DoubleIterator
                    vdouble$1$iter
                    = this.vdoubleIter("setAnte", 0);
                this.check_has_data
                    (vdouble$1$iter,
                     "this.vdoubleIter(\"setAnte\", 0)");
                while (!vdouble$1$iter.atEnd()) {
                    final poker.dealer.Blind receiver$
                        = (poker.dealer.Blind) receivers$iter.get();
                    final double newAnte
                        = vdouble$1$iter.getDouble();
                    methodTests$.addTest
                        (new TestSetAnte(receiver$, newAnte));
                    vdouble$1$iter.advance();
                }
                receivers$iter.advance();
            }
        } catch (org.jmlspecs.jmlunit.strategies.TestSuiteFullException e$) {
            // methodTests$ doesn't want more tests
        }
        overallTestSuite$.addTest(methodTests$);
    }

    /** Test for the setAnte method. */
    protected static class TestSetAnte extends OneTest {
        /** The receiver */
        private poker.dealer.Blind receiver$;
        /** Argument newAnte */
        private double newAnte;

        /** Initialize this instance. */
        public TestSetAnte(poker.dealer.Blind receiver$, double newAnte) {
            super("setAnte"+ ":" + newAnte);
            this.receiver$ = receiver$;
            this.newAnte = newAnte;
        }

        protected void doCall() throws java.lang.Throwable {
            receiver$.setAnte(newAnte);
        }

        protected java.lang.String failMessage
            (org.jmlspecs.jmlrac.runtime.JMLAssertionError e$)
        {
            java.lang.String msg = "\n\tMethod 'setAnte' applied to";
            msg += "\n\tReceiver: " + this.receiver$;
            msg += "\n\tArgument newAnte: " + this.newAnte;
            return msg;
        }
    }

    /** Add tests for the getBig method
     * to the overall test suite. */
    private void addTestSuiteFor$TestGetBig
        (junit.framework.TestSuite overallTestSuite$)
    {
        junit.framework.TestSuite methodTests$
            = this.emptyTestSuiteFor("getBig");
        try {
            org.jmlspecs.jmlunit.strategies.IndefiniteIterator
                receivers$iter
                = new org.jmlspecs.jmlunit.strategies.NonNullIteratorDecorator
                    (this.vpoker_dealer_BlindIter("getBig", 0));
            this.check_has_data
                (receivers$iter,
                 "new NonNullIteratorDecorator(this.vpoker_dealer_BlindIter(\"getBig\", 0))");
            while (!receivers$iter.atEnd()) {
                final poker.dealer.Blind receiver$
                    = (poker.dealer.Blind) receivers$iter.get();
                methodTests$.addTest
                    (new TestGetBig(receiver$));
                receivers$iter.advance();
            }
        } catch (org.jmlspecs.jmlunit.strategies.TestSuiteFullException e$) {
            // methodTests$ doesn't want more tests
        }
        overallTestSuite$.addTest(methodTests$);
    }

    /** Test for the getBig method. */
    protected static class TestGetBig extends OneTest {
        /** The receiver */
        private poker.dealer.Blind receiver$;

        /** Initialize this instance. */
        public TestGetBig(poker.dealer.Blind receiver$) {
            super("getBig");
            this.receiver$ = receiver$;
        }

        protected void doCall() throws java.lang.Throwable {
            receiver$.getBig();
        }

        protected java.lang.String failMessage
            (org.jmlspecs.jmlrac.runtime.JMLAssertionError e$)
        {
            java.lang.String msg = "\n\tMethod 'getBig' applied to";
            msg += "\n\tReceiver: " + this.receiver$;
            return msg;
        }
    }

    /** Add tests for the setBig method
     * to the overall test suite. */
    private void addTestSuiteFor$TestSetBig
        (junit.framework.TestSuite overallTestSuite$)
    {
        junit.framework.TestSuite methodTests$
            = this.emptyTestSuiteFor("setBig");
        try {
            org.jmlspecs.jmlunit.strategies.IndefiniteIterator
                receivers$iter
                = new org.jmlspecs.jmlunit.strategies.NonNullIteratorDecorator
                    (this.vpoker_dealer_BlindIter("setBig", 1));
            this.check_has_data
                (receivers$iter,
                 "new NonNullIteratorDecorator(this.vpoker_dealer_BlindIter(\"setBig\", 1))");
            while (!receivers$iter.atEnd()) {
                org.jmlspecs.jmlunit.strategies.DoubleIterator
                    vdouble$1$iter
                    = this.vdoubleIter("setBig", 0);
                this.check_has_data
                    (vdouble$1$iter,
                     "this.vdoubleIter(\"setBig\", 0)");
                while (!vdouble$1$iter.atEnd()) {
                    final poker.dealer.Blind receiver$
                        = (poker.dealer.Blind) receivers$iter.get();
                    final double newBig
                        = vdouble$1$iter.getDouble();
                    methodTests$.addTest
                        (new TestSetBig(receiver$, newBig));
                    vdouble$1$iter.advance();
                }
                receivers$iter.advance();
            }
        } catch (org.jmlspecs.jmlunit.strategies.TestSuiteFullException e$) {
            // methodTests$ doesn't want more tests
        }
        overallTestSuite$.addTest(methodTests$);
    }

    /** Test for the setBig method. */
    protected static class TestSetBig extends OneTest {
        /** The receiver */
        private poker.dealer.Blind receiver$;
        /** Argument newBig */
        private double newBig;

        /** Initialize this instance. */
        public TestSetBig(poker.dealer.Blind receiver$, double newBig) {
            super("setBig"+ ":" + newBig);
            this.receiver$ = receiver$;
            this.newBig = newBig;
        }

        protected void doCall() throws java.lang.Throwable {
            receiver$.setBig(newBig);
        }

        protected java.lang.String failMessage
            (org.jmlspecs.jmlrac.runtime.JMLAssertionError e$)
        {
            java.lang.String msg = "\n\tMethod 'setBig' applied to";
            msg += "\n\tReceiver: " + this.receiver$;
            msg += "\n\tArgument newBig: " + this.newBig;
            return msg;
        }
    }

    /** Add tests for the getSmall method
     * to the overall test suite. */
    private void addTestSuiteFor$TestGetSmall
        (junit.framework.TestSuite overallTestSuite$)
    {
        junit.framework.TestSuite methodTests$
            = this.emptyTestSuiteFor("getSmall");
        try {
            org.jmlspecs.jmlunit.strategies.IndefiniteIterator
                receivers$iter
                = new org.jmlspecs.jmlunit.strategies.NonNullIteratorDecorator
                    (this.vpoker_dealer_BlindIter("getSmall", 0));
            this.check_has_data
                (receivers$iter,
                 "new NonNullIteratorDecorator(this.vpoker_dealer_BlindIter(\"getSmall\", 0))");
            while (!receivers$iter.atEnd()) {
                final poker.dealer.Blind receiver$
                    = (poker.dealer.Blind) receivers$iter.get();
                methodTests$.addTest
                    (new TestGetSmall(receiver$));
                receivers$iter.advance();
            }
        } catch (org.jmlspecs.jmlunit.strategies.TestSuiteFullException e$) {
            // methodTests$ doesn't want more tests
        }
        overallTestSuite$.addTest(methodTests$);
    }

    /** Test for the getSmall method. */
    protected static class TestGetSmall extends OneTest {
        /** The receiver */
        private poker.dealer.Blind receiver$;

        /** Initialize this instance. */
        public TestGetSmall(poker.dealer.Blind receiver$) {
            super("getSmall");
            this.receiver$ = receiver$;
        }

        protected void doCall() throws java.lang.Throwable {
            receiver$.getSmall();
        }

        protected java.lang.String failMessage
            (org.jmlspecs.jmlrac.runtime.JMLAssertionError e$)
        {
            java.lang.String msg = "\n\tMethod 'getSmall' applied to";
            msg += "\n\tReceiver: " + this.receiver$;
            return msg;
        }
    }

    /** Add tests for the setSmall method
     * to the overall test suite. */
    private void addTestSuiteFor$TestSetSmall
        (junit.framework.TestSuite overallTestSuite$)
    {
        junit.framework.TestSuite methodTests$
            = this.emptyTestSuiteFor("setSmall");
        try {
            org.jmlspecs.jmlunit.strategies.IndefiniteIterator
                receivers$iter
                = new org.jmlspecs.jmlunit.strategies.NonNullIteratorDecorator
                    (this.vpoker_dealer_BlindIter("setSmall", 1));
            this.check_has_data
                (receivers$iter,
                 "new NonNullIteratorDecorator(this.vpoker_dealer_BlindIter(\"setSmall\", 1))");
            while (!receivers$iter.atEnd()) {
                org.jmlspecs.jmlunit.strategies.DoubleIterator
                    vdouble$1$iter
                    = this.vdoubleIter("setSmall", 0);
                this.check_has_data
                    (vdouble$1$iter,
                     "this.vdoubleIter(\"setSmall\", 0)");
                while (!vdouble$1$iter.atEnd()) {
                    final poker.dealer.Blind receiver$
                        = (poker.dealer.Blind) receivers$iter.get();
                    final double newSmall
                        = vdouble$1$iter.getDouble();
                    methodTests$.addTest
                        (new TestSetSmall(receiver$, newSmall));
                    vdouble$1$iter.advance();
                }
                receivers$iter.advance();
            }
        } catch (org.jmlspecs.jmlunit.strategies.TestSuiteFullException e$) {
            // methodTests$ doesn't want more tests
        }
        overallTestSuite$.addTest(methodTests$);
    }

    /** Test for the setSmall method. */
    protected static class TestSetSmall extends OneTest {
        /** The receiver */
        private poker.dealer.Blind receiver$;
        /** Argument newSmall */
        private double newSmall;

        /** Initialize this instance. */
        public TestSetSmall(poker.dealer.Blind receiver$, double newSmall) {
            super("setSmall"+ ":" + newSmall);
            this.receiver$ = receiver$;
            this.newSmall = newSmall;
        }

        protected void doCall() throws java.lang.Throwable {
            receiver$.setSmall(newSmall);
        }

        protected java.lang.String failMessage
            (org.jmlspecs.jmlrac.runtime.JMLAssertionError e$)
        {
            java.lang.String msg = "\n\tMethod 'setSmall' applied to";
            msg += "\n\tReceiver: " + this.receiver$;
            msg += "\n\tArgument newSmall: " + this.newSmall;
            return msg;
        }
    }

    /** Check that the iterator is non-null and not empty. */
    private void
    check_has_data(org.jmlspecs.jmlunit.strategies.IndefiniteIterator iter,
                   String call)
    {
        if (iter == null) {
            junit.framework.Assert.fail(call + " returned null");
        }
        if (iter.atEnd()) {
            junit.framework.Assert.fail(call + " returned an empty iterator");
        }
    }

    /** Converts a char to a printable String for display */
    public static String charToString(char c) {
        if (c == '\n') {
            return "NL";
        } else if (c == '\r') {
            return "CR";
        } else if (c == '\t') {
            return "TAB";
        } else if (Character.isISOControl(c)) {
            int i = (int)c;
            return "\\u"
                    + Character.forDigit((i/2048)%16,16)
                    + Character.forDigit((i/256)%16,16)
                    + Character.forDigit((i/16)%16,16)
                    + Character.forDigit((i)%16,16);
        }
        return Character.toString(c);
    }
}
