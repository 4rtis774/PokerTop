system_chart POKER_SYSTEM
    indexing
        author: "Chris";
    explanation
        "This hopefully will be a fully functional funny NL Texas Hold 'Em poker application."
    cluster POKER_PLAYER description "Player cluster."
    cluster UTILITIES description "Utilities to implement functionality such as initilization."
    cluster POKER_TABLE description "Table cluster."  
end

static_diagram POKER_SYSTEM
component 
    cluster POKER_TABLE
    component
        class TABLE
        indexing
            about: "A poker table."
        feature
            size: INTEGER -- Size of the poker table.
            seats: SET[SEAT] -- A set of seats
            
            get_size: INTEGER 
                ensure
                    Result = size;
                end -- get_size
            
            make: TABLE -- Construct table  
                -> the_new_size: INTEGER  -- Table size
                require
                    2 <= the_new_size;
                    10 >= the_new_size;
                ensure
                    Result.size = the_new_size;
                    get_size = the_new_size;
                end --make table
            
            count_empty_seats: INTEGER
                require
                    get_seats;
                ensure
                    Result /= Void;
                end
                
        invariant
            2 <= size ;
            10 >= size ;                
        end -- class TABLE
        
        class SEAT
        indexing
            about: "Representation of a seat at the table."
        feature
            position: INTEGER --Position of the seat at the table.
            player: PLAYER -- Name of player sitting in this seat.
            
            -- I am kind of thinking having only constructor for SEAT 
            make: SEAT
                -> new_position: INTEGER
	            require
	               new_position /= Void;
	            ensure
	                Result.position = new_position;
                    --Result.player.set_name = "empty" ;
	            end -- make seat               
            
            get_position: INTEGER
                ensure
                    Result = position;
                end --get_position
            
            get_player: PLAYER
                ensure
                    Result = player;
                end --get_player
            
            -- Check out how can add more functionality
            is_availiable: BOOLEAN
                require
                    get_player;
                end
            
            set_player
                -> new_player: PLAYER
                require
                    get_player;
                    new_player /= Void;
                ensure
                    not is_availiable();
                    get_player = new_player
                end
                                                        
        end -- class SEAT
        
        class PLAYER
        indexing
            about: "A poker player";
        --Possible need to define scope {NONE}
        feature
            name: STRING  -- Player's name in order to distinguish them on the table.
            bank: BANK -- Player's bank    
            
            make: PLAYER
                -> new_name: STRING
                require
                   new_name /= Void;
                ensure
                    Result.name = new_name;
                    Result.bank.set_amount(0);
                end -- make player
            
            get_name: STRING
                ensure
                    Result = name;
                end --get_name
            
            get_bank_amount: REAL
                require
                    bank.get_amount >= 0;                    
                ensure
                    Result = bank.get_amount();
                end -- get_bank_amount

            add_to_bank
                -> value_to_add: REAL
                require
                    value_to_add >= 0;
                    get_bank_amount();
                ensure
                    get_bank_amount = old(get_bank_amount) + value_to_add;
                end -- add to bank 
            
            subtract_from_bank
                -> value_to_sub: REAL
	            require
	                value_to_sub >= 0;
	                value_to_sub <= get_bank_amount();
	            ensure
	                get_bank_amount = old(get_bank_amount) - value_to_sub;
	            end -- subtract
	            
        invariant
            0 <= get_bank_amount();                               
        end -- class PLAYER
                
    end -- cluster POKER_TABLE
    
    cluster POKER_PLAYER
    component
        class BANK
        indexing
            about: "Bank of each player."
        feature{PLAYER}
            amount: REAL -- Players amount of money
            
            make: BANK -- Create a new initialised bank object
            ensure
                Result.amount = 0;
            end

            get_amount: REAL -- What's the current amount of money in bank.
                ensure
                  Result = amount;
                end

            set_amount  -- Set a new amount for bank.
                -> the_new_amount: REAL  -- Bank's new amount
                require
                    the_new_amount /= Void;
                    0 <= the_new_amount;
                ensure
                    get_amount = the_new_amount;
                end
        invariant
            0 <= amount;                          
        end --class BANK
        
    end -- cluster POKER_PLAYER    
    
    cluster UTILITIES
    component
        class RANDOM_GENERATOR
            feature
                input: VALUE
        end -- RANDOM_GENERATOR
        
        class INPUT_HANDLING
            feature
                input: VALUE
        end -- INPUT_HANDLING
        
        class PRINT_HANDLING
            feature
                input: VALUE
        end -- PRINT_HANDLING
        
        class LOG_HANDLING
            feature
                input: VALUE
        end -- LOG_HANDLING
    end -- cluster UTILITIES
    
end-- cluster SYSTEM